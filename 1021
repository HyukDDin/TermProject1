# app.py â€” ì˜í™” ì¶”ì²œ (Content-based) + ì¹´ë“œ/ëª¨ë‹¬ + í•„í„°/ì •ë ¬ + CSV
# ì‹¤í–‰: streamlit run app.py

from pathlib import Path
from ast import literal_eval
import re
import os, requests, urllib.parse

import pandas as pd
import streamlit as st
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# í˜ì´ì§€ ì „ë°˜ ì„¤ì •: íƒ­ ì œëª©/ì•„ì´ì½˜/ë ˆì´ì•„ì›ƒ(ê°€ë¡œ í­ ë„“ê²Œ)
st.set_page_config(page_title="ì˜í™” ì¶”ì²œ ì‹œìŠ¤í…œ", page_icon="ğŸ¬", layout="wide")

# -------------------------------
# 0) CSV ê²½ë¡œ (clean ìš°ì„ )
# -------------------------------
# í˜„ì¬ íŒŒì¼(app.py)ì˜ í´ë” ê²½ë¡œë¥¼ ê¸°ì¤€ìœ¼ë¡œ CSV íŒŒì¼ì„ ì°¾ëŠ”ë‹¤.
# movies_details_clean.csv ê°€ ìˆìœ¼ë©´(ì „ì²˜ë¦¬ ì™„ë£Œë³¸) ê·¸ê±¸ ìš°ì„  ì‚¬ìš©í•˜ê³ ,
# ì—†ìœ¼ë©´ ì›ë³¸ movies_details.csv ë¡œ ëŒ€ì²´í•œë‹¤.
# ë‘˜ ë‹¤ ì—†ìœ¼ë©´ ì•±ì„ ì¤‘ë‹¨í•˜ê³  ì—ëŸ¬ ë©”ì‹œì§€ ì¶œë ¥.
HERE = Path(__file__).parent
CSV_PATH = (HERE / "movies_details_clean.csv") if (HERE / "movies_details_clean.csv").exists() else (HERE / "movies_details.csv")
if not CSV_PATH.exists():
    st.error("CSV íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. app.pyì™€ ê°™ì€ í´ë”ì— movies_details_clean.csv ë˜ëŠ” movies_details.csvë¥¼ ë‘ì„¸ìš”.")
    st.stop()

# -------------------------------
# 1) ë°ì´í„° ë¡œë“œ/ì •ì œ
# -------------------------------
# ìºì‹œ: ê°™ì€ ì…ë ¥ìœ¼ë¡œ ì¬í˜¸ì¶œ ì‹œ ë””ìŠ¤í¬/CPU ë‚­ë¹„ë¥¼ ì¤„ì´ê¸° ìœ„í•´ ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ì— ì €ì¥í•œë‹¤.
@st.cache_data
def load_df(path: Path) -> pd.DataFrame:
    """CSVë¥¼ ì½ê³ , ê²°ì¸¡ì¹˜ ì±„ìš°ê¸°/ë¦¬ìŠ¤íŠ¸í˜• ë¬¸ìì—´ ì •ê·œí™”/íŒŒìƒì—´ ìƒì„±ê¹Œì§€ ìˆ˜í–‰í•œë‹¤."""
    df = pd.read_csv(path)

    # (1) ê²°ì¸¡ì¹˜ ì²˜ë¦¬: ì¶”ì²œ ë° UI í•„í„°ì—ì„œ ìì£¼ ì“°ëŠ” ì»¬ëŸ¼ì„ ìš°ì„ ì ìœ¼ë¡œ ë¹ˆ ë¬¸ìì—´ë¡œ ì±„ìš´ë‹¤.
    for col in ["genres","keywords","cast","director","overview","title","poster_path","release_date","vote_average"]:
        if col in df.columns:
            df[col] = df[col].fillna("")

    # (2) ë¬¸ìì—´ë¡œ ì €ì¥ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‹¤ì œ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸
    # ì˜ˆ) "['Action', 'Adventure']" -> ["Action", "Adventure"]
    # ì˜ˆ) "Action/Adventure" -> ["Action", "Adventure"]
    def to_list(x):
        if isinstance(x, list):
            return x
        s = str(x).strip()
        if not s:
            return []
        # ëŒ€ê´„í˜¸ í˜•íƒœë¼ë©´ literal_eval ë¡œ íŒŒì‹± ì‹œë„
        if s.startswith("[") and s.endswith("]"):
            try:
                v = literal_eval(s)
                if isinstance(v, list):
                    return [str(t) for t in v]
            except:
                pass
        # ê·¸ ì™¸ëŠ” ì½¤ë§ˆ/ìŠ¬ë˜ì‹œ/íŒŒì´í”„ êµ¬ë¶„ìë¡œ ë¶„í• 
        return [t.strip() for t in re.split(r"[,/|]", s) if t.strip()]

    # ëŒ€ìƒ ì»¬ëŸ¼ë“¤ì— to_list ì ìš© (ì¡´ì¬í•  ë•Œë§Œ)
    if "genres"   in df.columns: df["genres"]   = df["genres"].apply(to_list)
    if "keywords" in df.columns: df["keywords"] = df["keywords"].apply(to_list)
    if "cast"     in df.columns: df["cast"]     = df["cast"].apply(to_list)

    # (3) ì¶”ì²œìš© ê²°í•© í…ìŠ¤íŠ¸ ìƒì„±
    # - ì¥ë¥´/í‚¤ì›Œë“œ/ê°ë…/ë°°ìš°/ì¤„ê±°ë¦¬ë¥¼ í•˜ë‚˜ì˜ í° ë¬¸ì¥ìœ¼ë¡œ ì´ì–´ë¶™ì¸ë‹¤.
    # - ë¬¸ìì—´ ë°˜ë³µ("í…ìŠ¤íŠ¸" * N)ì€ ì‹¤ì œë¡œ ë‚´ìš©ì„ Në²ˆ ë°˜ë³µí•˜ëŠ” íš¨ê³¼(=ê°„ì ‘ì  ê°€ì¤‘ì¹˜)ì´ë‹¤.
    #   ì˜ˆ: "Action Drama " * 3 -> "Action Drama Action Drama Action Drama "
    df["combined_features"] = (
        (df["genres"].apply(" ".join)   + " ") * 3 +   # ì¥ë¥´(ë°˜ë³µ 3íšŒ == ë†’ì€ ê°€ì¤‘ì¹˜)
        (df["keywords"].apply(" ".join) + " ") * 2 +   # í‚¤ì›Œë“œ(ë°˜ë³µ 2íšŒ)
        (df["director"].astype(str)     + " ") * 2 +   # ê°ë…(ë°˜ë³µ 2íšŒ)
        (df["cast"].apply(" ".join)     + " ") * 1 +   # ë°°ìš°(ë°˜ë³µ 1íšŒ)
        df["overview"].astype(str)                         # ì¤„ê±°ë¦¬(ê·¸ëŒ€ë¡œ)
    )

    # (4) íŒŒìƒ: ê°œë´‰ì—°ë„(ì •ë ¬/í•„í„°/í‘œì‹œì— ìœ ìš©)
    # - release_date -> datetime íŒŒì‹± ì‹¤íŒ¨ ì‹œ NaT -> year ì¶”ì¶œ -> ê²°ì¸¡ì€ 0ìœ¼ë¡œ ì±„ì›€ -> int
    df["release_year"] = pd.to_datetime(df.get("release_date", ""), errors="coerce").dt.year.fillna(0).astype(int)
    return df

# ì‹¤ì œ ë°ì´í„°í”„ë ˆì„ ë¡œë“œ
df = load_df(CSV_PATH)
# íŒŒì¼ëª… ë° í¬ìŠ¤í„° ë³´ìœ  ê°œìˆ˜(ê°„ë‹¨í•œ ë°ì´í„° í’ˆì§ˆ ì§€í‘œ)ë¥¼ ìº¡ì…˜ìœ¼ë¡œ í‘œì‹œ
st.caption(f"ì½ì€ íŒŒì¼: {CSV_PATH.name} | í¬ìŠ¤í„° ìˆ˜: {(df['poster_path'].astype(str)!='').sum() if 'poster_path' in df.columns else 0}")

# -------------------------------
# 2) TF-IDF + ì½”ì‚¬ì¸ ìœ ì‚¬ë„ í–‰ë ¬ êµ¬ì„±
# -------------------------------
# - corpus(ë¬¸ì„œ ì§‘í•©)ì—ì„œ TF-IDF ë²¡í„°ë¥¼ ë§Œë“¤ê³ , ë¬¸ì„œ-ë¬¸ì„œ ê°„ ì½”ì‚¬ì¸ ìœ ì‚¬ë„(similarity) í–‰ë ¬ì„ êµ¬í•œë‹¤.
# - ìºì‹œ ë¦¬ì†ŒìŠ¤: ëª¨ë¸/í–‰ë ¬ì„ ë©”ëª¨ë¦¬ì— ìœ ì§€í•˜ì—¬ ì¬ì‚¬ìš©(ì†ë„ í–¥ìƒ).
@st.cache_resource
def build_model(corpus):
    """TF-IDF ë²¡í„°ë¼ì´ì €ì™€ ì „ì²´ ì½”ì‚¬ì¸ ìœ ì‚¬ë„ í–‰ë ¬ì„ êµ¬ì¶•í•œë‹¤."""
    # ngram_range=(1,2): ìœ ë‹ˆê·¸ë¨+ë°”ì´ê·¸ë¨ì„ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ í‘œí˜„ë ¥ì„ ë†’ì„
    vec = TfidfVectorizer(stop_words=None, min_df=1, ngram_range=(1, 2))
    X = vec.fit_transform(corpus)        # ë¬¸ì„œ-ë‹¨ì–´ í–‰ë ¬(í¬ì†Œ)
    sim = cosine_similarity(X, X)        # ëª¨ë“  ë¬¸ì„œìŒ ìœ ì‚¬ë„(ì •ë°©í–‰ë ¬)
    return vec, sim

_, cosine_sim = build_model(df["combined_features"])

# -------------------------------
# 3) ì¶”ì²œ í•¨ìˆ˜ (ê¸°ì¤€ ì¸ë±ìŠ¤ ê¸°ë°˜ Top-K)
# -------------------------------
# - ì…ë ¥ ì¸ë±ìŠ¤ì˜ ì˜í™”ì™€ ë‹¤ë¥¸ ëª¨ë“  ì˜í™” ì‚¬ì´ì˜ ìœ ì‚¬ë„ë¥¼ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
# - ìê¸° ìì‹  ì œì™¸ í›„ ìƒìœ„ Kê°œë¥¼ ì¶”ì¶œ
# - ì¹´ë“œ í‘œì‹œì— í•„ìš”í•œ ì»¬ëŸ¼ë“¤ë§Œ ê³¨ë¼ ê°€ê³µ/ë°˜ì˜¬ë¦¼/URL ìƒì„±

def recommend_by_index(idx: int, k: int = 10) -> pd.DataFrame:
    # enumerateë¡œ (ë¬¸ì„œì¸ë±ìŠ¤, ìœ ì‚¬ë„) íŠœí”Œ ë¦¬ìŠ¤íŠ¸ ìƒì„± â†’ ìœ ì‚¬ë„ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    sims = sorted(enumerate(cosine_sim[idx]), key=lambda x: x[1], reverse=True)
    sims = [s for s in sims if s[0] != idx][:k]           # ìê¸° ìì‹  ì œì™¸ í›„ ìƒìœ„ kê°œ
    rec_idx = [i for i, _ in sims]

    # ì¹´ë“œ í‘œì‹œë¥¼ ìœ„í•´ ìš°ì„ ì ìœ¼ë¡œ ë³´ì—¬ì¤„ ì»¬ëŸ¼ ëª©ë¡(ì¡´ì¬í•˜ëŠ” ê²ƒë§Œ keep)
    cols = ["id","title","genres","vote_average","release_date","release_year","poster_path","overview"]
    cols = [c for c in cols if c in df.columns]
    out = df.iloc[rec_idx][cols].reset_index(drop=True).copy()

    # ë¦¬ìŠ¤íŠ¸í˜• ì¥ë¥´ë¥¼ ì¹´ë“œ í‘œì‹œìš© ë¬¸ìì—´ë¡œ ë³€í™˜
    if "genres" in out.columns:
        out["genres"] = out["genres"].apply(lambda xs: ", ".join(xs) if isinstance(xs, list) else str(xs))
    # í‰ì ì€ ìˆ«ìë¡œ ë³€í™˜ í›„ ì†Œìˆ˜ 1ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼
    if "vote_average" in out.columns:
        out["vote_average"] = pd.to_numeric(out["vote_average"], errors="coerce").round(1)

    # TMDB í¬ìŠ¤í„° URL ìƒì„±(w185ëŠ” TMDBì˜ ì¸ë„¤ì¼ ì‚¬ì´ì¦ˆ ì½”ë“œ)
    if "poster_path" in out.columns:
        base = "https://image.tmdb.org/t/p/w185"
        out["poster_url"] = out["poster_path"].apply(lambda p: base + p if isinstance(p, str) and p else None)

    # ìœ ì‚¬ë„(score)ë„ í•¨ê»˜ ì œê³µ(ì§„ë‹¨/ì •ë ¬ ì°¸ê³ ìš©)
    out["similarity"] = [score for _, score in sims]
    out["similarity"] = out["similarity"].round(3)
    return out

# ---- YouTube ì˜ˆê³ í¸ URL ê°€ì ¸ì˜¤ê¸° (API í‚¤ ì—†ìœ¼ë©´ None) ----
# - ìºì‹œ ë°ì´í„°: ê°™ì€ ì œëª©/ì—°ë„ ìš”ì²­ì€ 24ì‹œê°„ ë™ì•ˆ ì¬ì‚¬ìš©
# - í™˜ê²½ë³€ìˆ˜(YOUTUBE_API_KEY) ë˜ëŠ” st.secrets ì—ì„œ API í‚¤ë¥¼ ì½ëŠ”ë‹¤.
@st.cache_data(show_spinner=False, ttl=60*60*24)
def fetch_youtube_trailer_url(title: str, year: int | None = None) -> str | None:
    """YouTube Data API v3ë¡œ '<ì œëª©> trailer (year)' ê²€ìƒ‰ â†’ ì²« ì˜ìƒ URL ë°˜í™˜.
    ì‹¤íŒ¨/í‚¤ ì—†ìŒ â†’ None"""
    api_key = os.environ.get("YOUTUBE_API_KEY") or st.secrets.get("YOUTUBE_API_KEY", None)
    if not api_key:
        return None
    try:
        # ê²€ìƒ‰ ì§ˆì˜: ì œëª© + 'trailer' + (ê°€ëŠ¥í•˜ë©´ ì—°ë„)
        q = f"{title} trailer{f' {year}' if year else ''}"
        params = {
            "part": "snippet", "q": q, "type": "video",
            "maxResults": 1, "regionCode": "KR",
            "key": api_key, "safeSearch": "none",
        }
        r = requests.get("https://www.googleapis.com/youtube/v3/search", params=params, timeout=10)
        r.raise_for_status()
        items = r.json().get("items", [])
        if items:
            vid = items[0]["id"]["videoId"]
            return f"https://www.youtube.com/watch?v={vid}"
    except Exception:
        # ë„¤íŠ¸ì›Œí¬/ì¿¼í„°/íŒŒì‹± ì˜¤ë¥˜ ë“±ì€ ì¡°ìš©íˆ ë¬´ì‹œí•˜ê³  None ë°˜í™˜
        pass
    return None


# ---- ìƒì„¸ 'ëª¨ë‹¬' í˜¸í™˜ ë ˆì´ì–´ ----
# - ìµœì‹  Streamlitì€ st.modal ì§€ì›. êµ¬ë²„ì „ì€ ì‚¬ì´ë“œë°”ë¥¼ ëª¨ë‹¬ ëŒ€ìš©ìœ¼ë¡œ ì‚¬ìš©.
# - ìƒì„¸ íŒ¨ë„ì—ì„œëŠ” í¬ìŠ¤í„°/ë©”íƒ€/ì¤„ê±°ë¦¬/TMDB ë§í¬/ìœ íŠœë¸Œ ì˜ˆê³ í¸ì„ ë³´ì—¬ì¤€ë‹¤.

def show_detail_modal(row: pd.Series):
    has_modal = hasattr(st, "modal")  # Streamlit ë²„ì „ì— ë”°ë¼ ëª¨ë‹¬ ì§€ì› ì—¬ë¶€ í™•ì¸

    # ì˜ˆê³ í¸ ê²€ìƒ‰ ì •í™•ë„ í–¥ìƒì„ ìœ„í•´ release_dateì—ì„œ ì—°ë„ ì¶”ì¶œ(ì‹¤íŒ¨ ì‹œ None)
    year = None
    if isinstance(row.get("release_date"), str) and row["release_date"].strip():
        try:
            year = int(pd.to_datetime(row["release_date"], errors="coerce").year)
        except Exception:
            year = None

    # ë‚´ë¶€: ì‹¤ì œ UI êµ¬ì„± ë¡œì§(ì»¨í…Œì´ë„ˆë¥¼ ì£¼ì…ë°›ì•„ ê³µí†µìœ¼ë¡œ ì‚¬ìš©)
    def _body(container):
        # (1) í¬ìŠ¤í„°
        url = row.get("poster_url") or "https://via.placeholder.com/185x278?text=No+Image"
        container.image(url, use_container_width=True)

        # (2) ë©”íƒ€ ì •ë³´(ê°œë´‰ì¼/í‰ì /ì¥ë¥´)
        meta = []
        if pd.notna(row.get("release_date")) and row.get("release_date"):
            meta.append(f"ê°œë´‰: {row['release_date']}")
        if "vote_average" in row:
            meta.append(f"â­ {row['vote_average']}")
        if meta:
            container.write(" | ".join(meta))
        if row.get("genres"):
            container.write(row["genres"])

        # (3) ì¤„ê±°ë¦¬(ìˆì„ ë•Œë§Œ)
        if isinstance(row.get("overview"), str) and row["overview"].strip():
            container.markdown("---")
            container.write(row["overview"])

        # (4) TMDB ìƒì„¸ í˜ì´ì§€ ë§í¬(idê°€ ìˆì„ ë•Œë§Œ)
        if "id" in row.index and pd.notna(row["id"]):
            tmdb_url = f"https://www.themoviedb.org/movie/{int(row['id'])}"
            container.markdown(f"[TMDBì—ì„œ ë³´ê¸°]({tmdb_url})")

        # (5) ğŸï¸ ìœ íŠœë¸Œ ì˜ˆê³ í¸(ê°€ëŠ¥í•˜ë©´ ë°”ë¡œ embed, ì—†ìœ¼ë©´ ê²€ìƒ‰ ë²„íŠ¼)
        container.markdown("### ğŸï¸ ì˜ˆê³ í¸")
        yt_url = fetch_youtube_trailer_url(row.get("title", ""), year)
        if yt_url:
            container.video(yt_url)
        else:
            q = urllib.parse.quote(f"{row.get('title','')} trailer {year or ''}")
            container.link_button("YouTubeì—ì„œ ì˜ˆê³ í¸ ê²€ìƒ‰", f"https://www.youtube.com/results?search_query={q}")

        # (6) ë‹«ê¸° ë²„íŠ¼: ì„¸ì…˜ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•˜ê³  í™”ë©´ ê°±ì‹ 
        if container.button("ë‹«ê¸°", key="close_detail"):
            st.session_state["open_modal"] = False
            st.session_state["detail_idx"] = None
            try:
                st.rerun()
            except Exception:
                st.experimental_rerun()

    # ì‹¤ì œ ëª¨ë‹¬/ì‚¬ì´ë“œë°”ë¡œ ëœë”ë§
    if has_modal:
        with st.modal(row.get("title", "ìƒì„¸ ë³´ê¸°")):
            _body(st)
    else:
        st.sidebar.markdown(f"### {row.get('title','ìƒì„¸ ë³´ê¸°')}")
        _body(st.sidebar)



# -------------------------------
# 5) ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™”
# -------------------------------
# - Streamlitì€ ë§¤ ì¸í„°ë™ì…˜ë§ˆë‹¤ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¬ì‹¤í–‰í•˜ë¯€ë¡œ, ìƒíƒœ ë³€ìˆ˜ëŠ” session_stateì— ë‘”ë‹¤.
# - result: ì¶”ì²œ ê²°ê³¼ DataFrame
# - open_modal: ìƒì„¸ ëª¨ë‹¬ í‘œì‹œ ì—¬ë¶€
# - detail_idx: ê²°ê³¼ ëª©ë¡ì—ì„œ í˜„ì¬ ìƒì„¸ í‘œì‹œ ì¤‘ì¸ í–‰ ì¸ë±ìŠ¤
# - selected_title: í˜„ì¬ ì„ íƒí•œ ê¸°ì¤€ ì˜í™” ì œëª©
st.session_state.setdefault("result", None)
st.session_state.setdefault("open_modal", False)
st.session_state.setdefault("detail_idx", None)
st.session_state.setdefault("selected_title", "")

# -------------------------------
# 6) UI ì»¨íŠ¸ë¡¤ (í•„í„°/ê²€ìƒ‰/ì •ë ¬/ê°œìˆ˜)
# -------------------------------
# ì œëª©ê³¼ í•¨ê»˜ ê¸°ë³¸ ì¸í„°ë™ì…˜ ìœ„ì ¯ë“¤ì„ êµ¬ì„±í•œë‹¤.
st.title("ğŸ¬ ì˜í™” ì¶”ì²œ ì‹œìŠ¤í…œ (Content-based)")

# (A) ì¥ë¥´ í•„í„°: ë°ì´í„° ì „ì²´ì˜ ì¥ë¥´ ì§‘í•©ì„ ì¶”ì¶œí•˜ì—¬ ë©€í‹°ì…€ë ‰íŠ¸ ì œê³µ
all_genres = sorted({g for gs in df["genres"] for g in (gs if isinstance(gs, list) else [])})
sel_genres = st.multiselect("ì¥ë¥´ í•„í„°", options=all_genres)

# (B) ê°œë´‰ì—°ë„/í‰ì /ì •ë ¬ ê¸°ì¤€ ì»¨íŠ¸ë¡¤
year_min = int(df["release_year"].replace(0, pd.NA).min() or 1900)  # 0(ë¯¸ìƒ)ì€ ì œì™¸í•˜ê³  ìµœì†Œê°’ ì¶”ì •
year_max = int(df["release_year"].max() or 2100)
f_year = st.slider("ê°œë´‰ ì—°ë„", min_value=year_min, max_value=year_max, value=(year_min, year_max))
f_vote = st.slider("í‰ì  í•˜í•œ", 0.0, 10.0, 0.0, 0.5)
sort_by = st.radio("ì •ë ¬", ["ìœ ì‚¬ë„", "í‰ì "], horizontal=True)

# (C) ì œëª© ê²€ìƒ‰/ì„ íƒ UI: ì™¼ìª½ì— ê²€ìƒ‰+ì…€ë ‰íŠ¸, ì˜¤ë¥¸ìª½ì— ì¶”ì²œ ê°œìˆ˜
left, right = st.columns([2,1])
with left:
    # ëª¨ë“  ì œëª© ëª©ë¡ ì¤€ë¹„(ì¤‘ë³µ/ê²°ì¸¡ ì œê±°)
    all_titles = sorted(df["title"].dropna().unique().tolist())
    # ë¹ ë¥¸ í…ìŠ¤íŠ¸ í•„í„°: ë¶€ë¶„ ì¼ì¹˜ë¡œ í›„ë³´ë¥¼ ì¤„ì—¬ ì„ íƒ í¸ì˜ ì œê³µ
    hint = st.text_input("ë¹ ë¥¸ ê²€ìƒ‰(ë¶€ë¶„ ì¼ì¹˜)")
    list_for_select = [t for t in all_titles if (hint.lower() in t.lower())] if hint else all_titles
    selected_title = st.selectbox("ì˜í™” ì œëª© ì„ íƒ(íƒ€ì´í•‘í•´ì„œ ê²€ìƒ‰ ê°€ëŠ¥)", options=list_for_select)
    st.session_state["selected_title"] = selected_title
with right:
    # ì¶”ì²œ ê²°ê³¼ ê°œìˆ˜ K (5~20)
    k = st.slider("ì¶”ì²œ ê°œìˆ˜", 5, 20, 10)

# -------------------------------
# 7) ì¶”ì²œ ë²„íŠ¼ â†’ ì„¸ì…˜ì— ì €ì¥ í›„ rerun
# -------------------------------
# - ë²„íŠ¼ í´ë¦­ ì‹œ: ê¸°ì¤€ ì˜í™” ì¸ë±ìŠ¤ ì°¾ê¸° â†’ ì¶”ì²œ â†’ í•„í„°/ì •ë ¬ â†’ ì„¸ì…˜ ì €ì¥ â†’ í™”ë©´ ê°±ì‹ 
if st.button("ì¶”ì²œ ë³´ê¸°"):
    # ì„ íƒí•œ ì œëª©ì— í•´ë‹¹í•˜ëŠ” ì›ë³¸ dfì˜ ì¸ë±ìŠ¤(ì²« ë²ˆì§¸ í•­ëª©) ì·¨ë“
    base_idx = int(df.index[df["title"] == st.session_state["selected_title"]][0])
    result = recommend_by_index(base_idx, k).copy()

    # ì¶”ì²œ ê²°ê³¼ì— íŒŒìƒ/ì •ìˆ˜ ë³€í™˜ ë³´ì •(í•„í„°ì— í•„ìš”í•œ ì»¬ëŸ¼ì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê°€ë“œ)
    if "release_year" not in result.columns and "release_date" in result.columns:
        result["release_year"] = pd.to_datetime(result["release_date"], errors="coerce").dt.year
    if "vote_average" in result.columns:
        result["vote_average"] = pd.to_numeric(result["vote_average"], errors="coerce").fillna(0)

    # (í•„í„°) ì¥ë¥´: ì‚¬ìš©ìê°€ ê³ ë¥¸ ì¥ë¥´ ì§‘í•©ì´ ê²°ê³¼ì˜ ì¥ë¥´(ë¬¸ìì—´) superset ì¸ì§€ ê²€ì‚¬
    if sel_genres:
        result = result[result["genres"].apply(
            lambda s: set(sel_genres).issubset(set(map(str.strip, s.split(","))))
            if isinstance(s, str) else False
        )]
    # (í•„í„°) ê°œë´‰ì—°ë„ êµ¬ê°„
    if "release_year" in result.columns:
        result = result[result["release_year"].between(f_year[0], f_year[1])]
    # (í•„í„°) í‰ì  í•˜í•œ
    if "vote_average" in result.columns:
        result = result[result["vote_average"] >= f_vote]

    # (ì •ë ¬) í‰ì  ìš°ì„  ì„ íƒ ì‹œ, í‰ì  ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
    if sort_by == "í‰ì " and "vote_average" in result.columns:
        result = result.sort_values("vote_average", ascending=False)
    result = result.reset_index(drop=True)

    # ì„¸ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ í™”ë©´ ë¦¬í”„ë ˆì‹œ(ì¹´ë“œ ë Œë”ë§ ë‹¨ê³„ë¡œ ì´ë™)
    st.session_state["result"] = result
    st.session_state["open_modal"] = False
    st.session_state["detail_idx"] = None
    st.rerun()

# -------------------------------
# 8) ê²°ê³¼ ì¹´ë“œ ë Œë”ë§ + CSV ë‹¤ìš´ë¡œë“œ
# -------------------------------
# - ì„¸ì…˜ì— ì €ì¥ëœ result DataFrameì„ 5ì—´ ê·¸ë¦¬ë“œ ì¹´ë“œë¡œ í‘œì¶œ
# - ê° ì¹´ë“œ: í¬ìŠ¤í„°/ì œëª©/í‰ì /ìœ ì‚¬ë„/ì¥ë¥´ + 'ìƒì„¸ë³´ê¸°' ë²„íŠ¼
# - ì „ì²´ ê²°ê³¼ë¥¼ CSVë¡œ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ë²„íŠ¼ ì œê³µ
result = st.session_state.get("result")
if isinstance(result, pd.DataFrame) and not result.empty:
    cols = st.columns(5)
    placeholder = "https://via.placeholder.com/185x278?text=No+Image"
    for i, row in result.iterrows():
        with cols[i % 5]:
            url = row.get("poster_url") or placeholder
            st.image(url, use_container_width=True)
            st.caption(row["title"])  # ì œëª©ì€ ìº¡ì…˜ìœ¼ë¡œ ê°„ê²°í•˜ê²Œ
            meta = []
            if "vote_average" in row: meta.append(f"â­ {row['vote_average']}")
            meta.append(f"ìœ ì‚¬ë„ {row['similarity']}")
            st.write(" | ".join(meta))
            if "genres" in row: st.write(row["genres"])
            if st.button("ìƒì„¸ë³´ê¸°", key=f"detail_{i}"):
                st.session_state["open_modal"] = True
                st.session_state["detail_idx"] = i
                st.rerun()

    # CSV ë‹¤ìš´ë¡œë“œ(UTF-8-SIG: ì—‘ì…€ í•œê¸€ ê¹¨ì§ ë°©ì§€)
    csv = result.to_csv(index=False).encode("utf-8-sig")
    st.download_button(
        "CSVë¡œ ì €ì¥",
        data=csv,
        file_name=f"recommend_{st.session_state.get('selected_title','selection')}.csv",
        mime="text/csv",
        type="primary",
    )

# -------------------------------
# 9) ëª¨ë‹¬ í‘œì‹œ (ì„¸ì…˜ ìƒíƒœ ê¸°ë°˜)
# -------------------------------
# - 'ìƒì„¸ë³´ê¸°'ë¥¼ ëˆ„ë¥´ë©´ ì„¸ì…˜ì— ì €ì¥ëœ detail_idx í–‰ì„ ëª¨ë‹¬(ë˜ëŠ” ì‚¬ì´ë“œë°”)ë¡œ í‘œì‹œ
if st.session_state.get("open_modal") and st.session_state.get("detail_idx") is not None:
    i = st.session_state["detail_idx"]
    if isinstance(st.session_state.get("result"), pd.DataFrame) and 0 <= i < len(st.session_state["result"]):
        row = st.session_state["result"].iloc[i]
        show_detail_modal(row)

# -------------------------------
# 10) ë°ì´í„° ìƒ˜í”Œ
# -------------------------------
# - ìƒë‹¨ì—ì„œ ë¡œë“œí•œ ì›ë³¸ dfì˜ í•µì‹¬ ì»¬ëŸ¼ ì¼ë¶€ë¥¼ ë¯¸ë¦¬ë³´ê¸°ë¡œ ì œê³µ(ë””ë²„ê¹…/ì ê²€ìš©)
with st.expander("ë°ì´í„° ìƒ˜í”Œ ë³´ê¸°"):
    base_cols = [c for c in ["title","genres","vote_average","release_date","poster_path"] if c in df.columns]
    st.dataframe(df[base_cols].head(10))
