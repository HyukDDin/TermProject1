# app.py — 영화 추천 (Content-based) + 카드/모달 + 필터/정렬 + CSV
# 실행: streamlit run app.py

from pathlib import Path
from ast import literal_eval
import re
import os, requests, urllib.parse

import pandas as pd
import streamlit as st
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# 페이지 전반 설정: 탭 제목/아이콘/레이아웃(가로 폭 넓게)
st.set_page_config(page_title="영화 추천 시스템", page_icon="🎬", layout="wide")

# -------------------------------
# 0) CSV 경로 (clean 우선)
# -------------------------------
# 현재 파일(app.py)의 폴더 경로를 기준으로 CSV 파일을 찾는다.
# movies_details_clean.csv 가 있으면(전처리 완료본) 그걸 우선 사용하고,
# 없으면 원본 movies_details.csv 로 대체한다.
# 둘 다 없으면 앱을 중단하고 에러 메시지 출력.
HERE = Path(__file__).parent
CSV_PATH = (HERE / "movies_details_clean.csv") if (HERE / "movies_details_clean.csv").exists() else (HERE / "movies_details.csv")
if not CSV_PATH.exists():
    st.error("CSV 파일이 없습니다. app.py와 같은 폴더에 movies_details_clean.csv 또는 movies_details.csv를 두세요.")
    st.stop()

# -------------------------------
# 1) 데이터 로드/정제
# -------------------------------
# 캐시: 같은 입력으로 재호출 시 디스크/CPU 낭비를 줄이기 위해 결과를 메모리에 저장한다.
@st.cache_data
def load_df(path: Path) -> pd.DataFrame:
    """CSV를 읽고, 결측치 채우기/리스트형 문자열 정규화/파생열 생성까지 수행한다."""
    df = pd.read_csv(path)

    # (1) 결측치 처리: 추천 및 UI 필터에서 자주 쓰는 컬럼을 우선적으로 빈 문자열로 채운다.
    for col in ["genres","keywords","cast","director","overview","title","poster_path","release_date","vote_average"]:
        if col in df.columns:
            df[col] = df[col].fillna("")

    # (2) 문자열로 저장된 리스트를 실제 리스트로 변환하는 유틸
    # 예) "['Action', 'Adventure']" -> ["Action", "Adventure"]
    # 예) "Action/Adventure" -> ["Action", "Adventure"]
    def to_list(x):
        if isinstance(x, list):
            return x
        s = str(x).strip()
        if not s:
            return []
        # 대괄호 형태라면 literal_eval 로 파싱 시도
        if s.startswith("[") and s.endswith("]"):
            try:
                v = literal_eval(s)
                if isinstance(v, list):
                    return [str(t) for t in v]
            except:
                pass
        # 그 외는 콤마/슬래시/파이프 구분자로 분할
        return [t.strip() for t in re.split(r"[,/|]", s) if t.strip()]

    # 대상 컬럼들에 to_list 적용 (존재할 때만)
    if "genres"   in df.columns: df["genres"]   = df["genres"].apply(to_list)
    if "keywords" in df.columns: df["keywords"] = df["keywords"].apply(to_list)
    if "cast"     in df.columns: df["cast"]     = df["cast"].apply(to_list)

    # (3) 추천용 결합 텍스트 생성
    # - 장르/키워드/감독/배우/줄거리를 하나의 큰 문장으로 이어붙인다.
    # - 문자열 반복("텍스트" * N)은 실제로 내용을 N번 반복하는 효과(=간접적 가중치)이다.
    #   예: "Action Drama " * 3 -> "Action Drama Action Drama Action Drama "
    df["combined_features"] = (
        (df["genres"].apply(" ".join)   + " ") * 3 +   # 장르(반복 3회 == 높은 가중치)
        (df["keywords"].apply(" ".join) + " ") * 2 +   # 키워드(반복 2회)
        (df["director"].astype(str)     + " ") * 2 +   # 감독(반복 2회)
        (df["cast"].apply(" ".join)     + " ") * 1 +   # 배우(반복 1회)
        df["overview"].astype(str)                         # 줄거리(그대로)
    )

    # (4) 파생: 개봉연도(정렬/필터/표시에 유용)
    # - release_date -> datetime 파싱 실패 시 NaT -> year 추출 -> 결측은 0으로 채움 -> int
    df["release_year"] = pd.to_datetime(df.get("release_date", ""), errors="coerce").dt.year.fillna(0).astype(int)
    return df

# 실제 데이터프레임 로드
df = load_df(CSV_PATH)
# 파일명 및 포스터 보유 개수(간단한 데이터 품질 지표)를 캡션으로 표시
st.caption(f"읽은 파일: {CSV_PATH.name} | 포스터 수: {(df['poster_path'].astype(str)!='').sum() if 'poster_path' in df.columns else 0}")

# -------------------------------
# 2) TF-IDF + 코사인 유사도 행렬 구성
# -------------------------------
# - corpus(문서 집합)에서 TF-IDF 벡터를 만들고, 문서-문서 간 코사인 유사도(similarity) 행렬을 구한다.
# - 캐시 리소스: 모델/행렬을 메모리에 유지하여 재사용(속도 향상).
@st.cache_resource
def build_model(corpus):
    """TF-IDF 벡터라이저와 전체 코사인 유사도 행렬을 구축한다."""
    # ngram_range=(1,2): 유니그램+바이그램을 함께 사용하여 표현력을 높임
    vec = TfidfVectorizer(stop_words=None, min_df=1, ngram_range=(1, 2))
    X = vec.fit_transform(corpus)        # 문서-단어 행렬(희소)
    sim = cosine_similarity(X, X)        # 모든 문서쌍 유사도(정방행렬)
    return vec, sim

_, cosine_sim = build_model(df["combined_features"])

# -------------------------------
# 3) 추천 함수 (기준 인덱스 기반 Top-K)
# -------------------------------
# - 입력 인덱스의 영화와 다른 모든 영화 사이의 유사도를 내림차순 정렬
# - 자기 자신 제외 후 상위 K개를 추출
# - 카드 표시에 필요한 컬럼들만 골라 가공/반올림/URL 생성

def recommend_by_index(idx: int, k: int = 10) -> pd.DataFrame:
    # enumerate로 (문서인덱스, 유사도) 튜플 리스트 생성 → 유사도 내림차순 정렬
    sims = sorted(enumerate(cosine_sim[idx]), key=lambda x: x[1], reverse=True)
    sims = [s for s in sims if s[0] != idx][:k]           # 자기 자신 제외 후 상위 k개
    rec_idx = [i for i, _ in sims]

    # 카드 표시를 위해 우선적으로 보여줄 컬럼 목록(존재하는 것만 keep)
    cols = ["id","title","genres","vote_average","release_date","release_year","poster_path","overview"]
    cols = [c for c in cols if c in df.columns]
    out = df.iloc[rec_idx][cols].reset_index(drop=True).copy()

    # 리스트형 장르를 카드 표시용 문자열로 변환
    if "genres" in out.columns:
        out["genres"] = out["genres"].apply(lambda xs: ", ".join(xs) if isinstance(xs, list) else str(xs))
    # 평점은 숫자로 변환 후 소수 1자리로 반올림
    if "vote_average" in out.columns:
        out["vote_average"] = pd.to_numeric(out["vote_average"], errors="coerce").round(1)

    # TMDB 포스터 URL 생성(w185는 TMDB의 썸네일 사이즈 코드)
    if "poster_path" in out.columns:
        base = "https://image.tmdb.org/t/p/w185"
        out["poster_url"] = out["poster_path"].apply(lambda p: base + p if isinstance(p, str) and p else None)

    # 유사도(score)도 함께 제공(진단/정렬 참고용)
    out["similarity"] = [score for _, score in sims]
    out["similarity"] = out["similarity"].round(3)
    return out

# ---- YouTube 예고편 URL 가져오기 (API 키 없으면 None) ----
# - 캐시 데이터: 같은 제목/연도 요청은 24시간 동안 재사용
# - 환경변수(YOUTUBE_API_KEY) 또는 st.secrets 에서 API 키를 읽는다.
@st.cache_data(show_spinner=False, ttl=60*60*24)
def fetch_youtube_trailer_url(title: str, year: int | None = None) -> str | None:
    """YouTube Data API v3로 '<제목> trailer (year)' 검색 → 첫 영상 URL 반환.
    실패/키 없음 → None"""
    api_key = os.environ.get("YOUTUBE_API_KEY") or st.secrets.get("YOUTUBE_API_KEY", None)
    if not api_key:
        return None
    try:
        # 검색 질의: 제목 + 'trailer' + (가능하면 연도)
        q = f"{title} trailer{f' {year}' if year else ''}"
        params = {
            "part": "snippet", "q": q, "type": "video",
            "maxResults": 1, "regionCode": "KR",
            "key": api_key, "safeSearch": "none",
        }
        r = requests.get("https://www.googleapis.com/youtube/v3/search", params=params, timeout=10)
        r.raise_for_status()
        items = r.json().get("items", [])
        if items:
            vid = items[0]["id"]["videoId"]
            return f"https://www.youtube.com/watch?v={vid}"
    except Exception:
        # 네트워크/쿼터/파싱 오류 등은 조용히 무시하고 None 반환
        pass
    return None


# ---- 상세 '모달' 호환 레이어 ----
# - 최신 Streamlit은 st.modal 지원. 구버전은 사이드바를 모달 대용으로 사용.
# - 상세 패널에서는 포스터/메타/줄거리/TMDB 링크/유튜브 예고편을 보여준다.

def show_detail_modal(row: pd.Series):
    has_modal = hasattr(st, "modal")  # Streamlit 버전에 따라 모달 지원 여부 확인

    # 예고편 검색 정확도 향상을 위해 release_date에서 연도 추출(실패 시 None)
    year = None
    if isinstance(row.get("release_date"), str) and row["release_date"].strip():
        try:
            year = int(pd.to_datetime(row["release_date"], errors="coerce").year)
        except Exception:
            year = None

    # 내부: 실제 UI 구성 로직(컨테이너를 주입받아 공통으로 사용)
    def _body(container):
        # (1) 포스터
        url = row.get("poster_url") or "https://via.placeholder.com/185x278?text=No+Image"
        container.image(url, use_container_width=True)

        # (2) 메타 정보(개봉일/평점/장르)
        meta = []
        if pd.notna(row.get("release_date")) and row.get("release_date"):
            meta.append(f"개봉: {row['release_date']}")
        if "vote_average" in row:
            meta.append(f"⭐ {row['vote_average']}")
        if meta:
            container.write(" | ".join(meta))
        if row.get("genres"):
            container.write(row["genres"])

        # (3) 줄거리(있을 때만)
        if isinstance(row.get("overview"), str) and row["overview"].strip():
            container.markdown("---")
            container.write(row["overview"])

        # (4) TMDB 상세 페이지 링크(id가 있을 때만)
        if "id" in row.index and pd.notna(row["id"]):
            tmdb_url = f"https://www.themoviedb.org/movie/{int(row['id'])}"
            container.markdown(f"[TMDB에서 보기]({tmdb_url})")

        # (5) 🎞️ 유튜브 예고편(가능하면 바로 embed, 없으면 검색 버튼)
        container.markdown("### 🎞️ 예고편")
        yt_url = fetch_youtube_trailer_url(row.get("title", ""), year)
        if yt_url:
            container.video(yt_url)
        else:
            q = urllib.parse.quote(f"{row.get('title','')} trailer {year or ''}")
            container.link_button("YouTube에서 예고편 검색", f"https://www.youtube.com/results?search_query={q}")

        # (6) 닫기 버튼: 세션 상태를 초기화하고 화면 갱신
        if container.button("닫기", key="close_detail"):
            st.session_state["open_modal"] = False
            st.session_state["detail_idx"] = None
            try:
                st.rerun()
            except Exception:
                st.experimental_rerun()

    # 실제 모달/사이드바로 랜더링
    if has_modal:
        with st.modal(row.get("title", "상세 보기")):
            _body(st)
    else:
        st.sidebar.markdown(f"### {row.get('title','상세 보기')}")
        _body(st.sidebar)



# -------------------------------
# 5) 세션 상태 초기화
# -------------------------------
# - Streamlit은 매 인터랙션마다 스크립트를 재실행하므로, 상태 변수는 session_state에 둔다.
# - result: 추천 결과 DataFrame
# - open_modal: 상세 모달 표시 여부
# - detail_idx: 결과 목록에서 현재 상세 표시 중인 행 인덱스
# - selected_title: 현재 선택한 기준 영화 제목
st.session_state.setdefault("result", None)
st.session_state.setdefault("open_modal", False)
st.session_state.setdefault("detail_idx", None)
st.session_state.setdefault("selected_title", "")

# -------------------------------
# 6) UI 컨트롤 (필터/검색/정렬/개수)
# -------------------------------
# 제목과 함께 기본 인터랙션 위젯들을 구성한다.
st.title("🎬 영화 추천 시스템 (Content-based)")

# (A) 장르 필터: 데이터 전체의 장르 집합을 추출하여 멀티셀렉트 제공
all_genres = sorted({g for gs in df["genres"] for g in (gs if isinstance(gs, list) else [])})
sel_genres = st.multiselect("장르 필터", options=all_genres)

# (B) 개봉연도/평점/정렬 기준 컨트롤
year_min = int(df["release_year"].replace(0, pd.NA).min() or 1900)  # 0(미상)은 제외하고 최소값 추정
year_max = int(df["release_year"].max() or 2100)
f_year = st.slider("개봉 연도", min_value=year_min, max_value=year_max, value=(year_min, year_max))
f_vote = st.slider("평점 하한", 0.0, 10.0, 0.0, 0.5)
sort_by = st.radio("정렬", ["유사도", "평점"], horizontal=True)

# (C) 제목 검색/선택 UI: 왼쪽에 검색+셀렉트, 오른쪽에 추천 개수
left, right = st.columns([2,1])
with left:
    # 모든 제목 목록 준비(중복/결측 제거)
    all_titles = sorted(df["title"].dropna().unique().tolist())
    # 빠른 텍스트 필터: 부분 일치로 후보를 줄여 선택 편의 제공
    hint = st.text_input("빠른 검색(부분 일치)")
    list_for_select = [t for t in all_titles if (hint.lower() in t.lower())] if hint else all_titles
    selected_title = st.selectbox("영화 제목 선택(타이핑해서 검색 가능)", options=list_for_select)
    st.session_state["selected_title"] = selected_title
with right:
    # 추천 결과 개수 K (5~20)
    k = st.slider("추천 개수", 5, 20, 10)

# -------------------------------
# 7) 추천 버튼 → 세션에 저장 후 rerun
# -------------------------------
# - 버튼 클릭 시: 기준 영화 인덱스 찾기 → 추천 → 필터/정렬 → 세션 저장 → 화면 갱신
if st.button("추천 보기"):
    # 선택한 제목에 해당하는 원본 df의 인덱스(첫 번째 항목) 취득
    base_idx = int(df.index[df["title"] == st.session_state["selected_title"]][0])
    result = recommend_by_index(base_idx, k).copy()

    # 추천 결과에 파생/정수 변환 보정(필터에 필요한 컬럼이 없을 수 있으므로 가드)
    if "release_year" not in result.columns and "release_date" in result.columns:
        result["release_year"] = pd.to_datetime(result["release_date"], errors="coerce").dt.year
    if "vote_average" in result.columns:
        result["vote_average"] = pd.to_numeric(result["vote_average"], errors="coerce").fillna(0)

    # (필터) 장르: 사용자가 고른 장르 집합이 결과의 장르(문자열) superset 인지 검사
    if sel_genres:
        result = result[result["genres"].apply(
            lambda s: set(sel_genres).issubset(set(map(str.strip, s.split(","))))
            if isinstance(s, str) else False
        )]
    # (필터) 개봉연도 구간
    if "release_year" in result.columns:
        result = result[result["release_year"].between(f_year[0], f_year[1])]
    # (필터) 평점 하한
    if "vote_average" in result.columns:
        result = result[result["vote_average"] >= f_vote]

    # (정렬) 평점 우선 선택 시, 평점 내림차순으로 정렬
    if sort_by == "평점" and "vote_average" in result.columns:
        result = result.sort_values("vote_average", ascending=False)
    result = result.reset_index(drop=True)

    # 세션 상태 업데이트 후 화면 리프레시(카드 렌더링 단계로 이동)
    st.session_state["result"] = result
    st.session_state["open_modal"] = False
    st.session_state["detail_idx"] = None
    st.rerun()

# -------------------------------
# 8) 결과 카드 렌더링 + CSV 다운로드
# -------------------------------
# - 세션에 저장된 result DataFrame을 5열 그리드 카드로 표출
# - 각 카드: 포스터/제목/평점/유사도/장르 + '상세보기' 버튼
# - 전체 결과를 CSV로 다운로드하는 버튼 제공
result = st.session_state.get("result")
if isinstance(result, pd.DataFrame) and not result.empty:
    cols = st.columns(5)
    placeholder = "https://via.placeholder.com/185x278?text=No+Image"
    for i, row in result.iterrows():
        with cols[i % 5]:
            url = row.get("poster_url") or placeholder
            st.image(url, use_container_width=True)
            st.caption(row["title"])  # 제목은 캡션으로 간결하게
            meta = []
            if "vote_average" in row: meta.append(f"⭐ {row['vote_average']}")
            meta.append(f"유사도 {row['similarity']}")
            st.write(" | ".join(meta))
            if "genres" in row: st.write(row["genres"])
            if st.button("상세보기", key=f"detail_{i}"):
                st.session_state["open_modal"] = True
                st.session_state["detail_idx"] = i
                st.rerun()

    # CSV 다운로드(UTF-8-SIG: 엑셀 한글 깨짐 방지)
    csv = result.to_csv(index=False).encode("utf-8-sig")
    st.download_button(
        "CSV로 저장",
        data=csv,
        file_name=f"recommend_{st.session_state.get('selected_title','selection')}.csv",
        mime="text/csv",
        type="primary",
    )

# -------------------------------
# 9) 모달 표시 (세션 상태 기반)
# -------------------------------
# - '상세보기'를 누르면 세션에 저장된 detail_idx 행을 모달(또는 사이드바)로 표시
if st.session_state.get("open_modal") and st.session_state.get("detail_idx") is not None:
    i = st.session_state["detail_idx"]
    if isinstance(st.session_state.get("result"), pd.DataFrame) and 0 <= i < len(st.session_state["result"]):
        row = st.session_state["result"].iloc[i]
        show_detail_modal(row)

# -------------------------------
# 10) 데이터 샘플
# -------------------------------
# - 상단에서 로드한 원본 df의 핵심 컬럼 일부를 미리보기로 제공(디버깅/점검용)
with st.expander("데이터 샘플 보기"):
    base_cols = [c for c in ["title","genres","vote_average","release_date","poster_path"] if c in df.columns]
    st.dataframe(df[base_cols].head(10))
